# Versioned Download System

This system provides permanent, versioned links to downloaded files to ensure users can always access the exact same file versions even after updates.

## How It Works

Every time a user downloads files (single file or ZIP), the system:

1. **Creates a snapshot** containing:
   - Database record with metadata and file references
   - File hashes for integrity checking
   - Timestamp information
   - Deterministic snapshot ID based on file set

2. **Returns download with permanent link**:
   - All downloads include a `_PERMANENT_DOWNLOAD_LINK.txt` file
   - Contains permanent URL to access this exact version
   - Even single files are zipped to include the link
   - Response headers include snapshot metadata

3. **Preserves snapshots forever** - Links remain valid permanently

## Key Features

- **Automatic Link Inclusion**: Every download includes `_PERMANENT_DOWNLOAD_LINK.txt`
- **Single File Zipping**: Even single file downloads become ZIP files with link
- **Multi-file Support**: All multi-file downloads include the link
- **Admin Export Support**: Export functionality includes permanent links
- **Deterministic URLs**: Same file set always generates same permanent URL
- **Alphabetical Ordering**: Link file starts with `_` to appear at top when extracted

## Link Text File Format

Every download includes a `_PERMANENT_DOWNLOAD_LINK.txt` file with content like:

```
Permanent Download Link
========================

This download was created on: 2024-10-25 14:30:22 UTC
Download name: example_file.pb.zip

Permanent Link (never expires):
https://pabulib.org/download/snapshot/a1b2c3d4e5f6789a

What is this?
This link will always download the exact same files that were included 
in your original download, even if the source files are updated later.

Technical Details:
- Snapshot ID: a1b2c3d4e5f6789a
- This link is deterministic: the same set of files always generates 
  the same permanent URL
- The link works independently of when files were last updated
- Files are served from their current storage location, not duplicated

---
Generated by PabuLib
```

## Snapshot Storage

### Lightweight Approach - No File Duplication

Instead of copying files, we store **references** to the original files:

### File Structure
```
cache/
└── 20241025T143022Z/
    └── all_pb_files.zip  # Original cache files only
```

### Database Tables

#### `download_snapshots`
- `snapshot_id`: Deterministic hash based on file set (same files = same link)
- `download_name`: Original download filename
- `file_count`: Number of files in the snapshot
- `download_type`: 'single', 'multi', 'export'
- `created_at`: Snapshot creation timestamp

#### `download_snapshot_files`
- `snapshot_id`: Links to parent snapshot
- `file_id`: Original PBFile.id (points to current OR archived version)
- `file_name`: Original filename at time of download
- `file_path_at_snapshot`: File path when snapshot was created
- `file_mtime_at_snapshot`: File modification time at snapshot
- `file_hash`: SHA-256 hash for integrity verification

### How It Works

1. **Snapshot Creation**: 
   - Calculate deterministic hash based on sorted file IDs
   - Same file set = same hash = same permanent link
   - Record which file IDs were included
2. **Snapshot Access**: When accessing `/download/snapshot/<hash>`:
   - Look up the snapshot in database
   - Get all file IDs from that snapshot
   - Serve files from their current locations (pb_files/ or pb_files_deprecated/)
   - Create ZIP on-the-fly if multiple files

This way:
- ✅ **No file duplication** - saves massive disk space
- ✅ **Permanent links** - snapshot URLs always work
- ✅ **Access to exact versions** - even if files are updated/deleted
- ✅ **Efficient storage** - only metadata in database
- ✅ **Deterministic links** - same file set always generates same URL

## API Endpoints

### Download with Snapshots
All download endpoints now include snapshot headers:

- `GET /download/<filename>` - Single file download
- `POST /download-selected/start` - Multi-file download (background)
- `GET /admin/export/download/<relpath>` - Admin export download

### Snapshot Access
- `GET /download/snapshot/<snapshot_id>` - Download snapshot by ID
- `GET /download/snapshot/<snapshot_id>/info` - Get snapshot metadata

### Admin Tools
- `POST /admin/export/create-snapshot` - Create snapshot for existing cache file
- Admin export page includes "Create Snapshot Link" buttons

## Usage Examples

### Creating Snapshot Links for Existing Cache Files

In the admin export interface, you can create snapshot links for existing cache files:

1. Go to Admin → Export
2. Find the desired export in the "Existing Exports" table  
3. Click "Create Snapshot Link" button
4. Copy the generated permanent URL

### Programmatic Access

```python
# Get snapshot information
response = requests.get(f'/download/snapshot/{snapshot_id}/info')
snapshot_info = response.json()

# Download snapshot
response = requests.get(f'/download/snapshot/{snapshot_id}')
with open('downloaded_file.zip', 'wb') as f:
    f.write(response.content)
```

### JavaScript Integration

```javascript
// After download, check for snapshot information
fetch('/download-selected/file/' + token)
  .then(response => {
    const snapshotId = response.headers.get('X-Download-Snapshot-ID');
    const snapshotUrl = response.headers.get('X-Download-Snapshot-URL');
    
    if (snapshotId) {
      console.log('Permanent link:', snapshotUrl);
      // Store or display the permanent link
    }
    
    return response.blob();
  });
```

## Database Setup

The snapshot system requires two new database tables:
- `download_snapshots` - stores snapshot metadata
- `download_snapshot_files` - stores file information at snapshot time

**Tables are created automatically** when the application starts via `models.py`. No manual migration is required.

The system will automatically start creating snapshots for new downloads once the application is running.

## Performance Considerations

- **Storage**: Minimal additional storage - only metadata is stored, not file duplicates
- **Database**: New tables add minimal overhead with proper indexing
- **Memory**: Snapshot creation is lightweight - only metadata processing
- **Network**: Snapshot creation adds minimal latency (~10-50ms)

## Security

- Snapshot IDs are UUIDs (not sequential) to prevent enumeration
- File hashes ensure integrity
- Snapshots respect the same access controls as original files
- No automatic cleanup preserves evidence for compliance

## Maintenance

The system requires no regular maintenance:
- Snapshots are preserved forever (no automatic cleanup)
- File integrity can be verified using stored hashes  
- Database records provide audit trail
- Manual cleanup possible if needed (not recommended)

For troubleshooting, check:
- `cache/snapshots/` directory permissions
- Database connectivity  
- Available disk space